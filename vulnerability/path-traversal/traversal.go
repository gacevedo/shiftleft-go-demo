package sqli

import (
	"net/http"

	"github.com/gen2brain/go-unarr"
	"github.com/julienschmidt/httprouter"
)

type PathTraversal struct{}

func New() PathTraversal {
	return PathTraversal{}
}

func (PathTraversal) SetRouter(r *httprouter.Router) {
	r.GET("/path-traversal", pathTraversalHandler)
}

func pathTraversalHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	// Validate the incoming request to prevent null bodies
	if r.Body == nil {
		http.Error(w, "No body found", http.StatusBadRequest)
		return
	}

	// Create a temporary directory to extract the archive
	tempDir, err := os.MkdirTemp("", "example")
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer os.RemoveAll(tempDir) // Cleanup the temporary directory

	// Use archiver library to unarchive the file, specifying the destination directory
	archive, err := zip.OpenReader(r.Body)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer archive.Close()

	for _, f := range archive.File {
		// Safely extract the files to the desired location
		filePath := filepath.Join(tempDir, f.Name)
		if !strings.HasPrefix(filePath, tempDir) {
			http.Error(w, "Invalid file path", http.StatusBadRequest)
			return
		}

		if f.FileInfo().IsDir() {
			os.MkdirAll(filePath, os.ModePerm)
			continue
		}

		if err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		dstFile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		fileInArchive, err := f.Open()
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		if _, err := io.Copy(dstFile, fileInArchive); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		dstFile.Close()
		fileInArchive.Close()
	}
}

	defer os.RemoveAll(tempDir) // clean up

	// Open the zip archive
	a, err := unarr.NewArchiveFromReader(r.Body)
	if err != nil {
		panic(err)
	}
	defer a.Close()

	// Extract each file from the archive
	for _, file := range a.Files() {
		// Validate the file path
		if filepath.HasPrefix(file.Name, "..") || filepath.IsAbs(file.Name) {
			panic("Invalid file path")
		}

		// Validate the file type
		mimeType, err := mimetype.DetectFile(file.Name)
		if err != nil || mimeType.Is("application/zip") {
			panic("Invalid file type")
		}

		// Extract the file
		_, err = file.Extract(filepath.Join(tempDir, file.Name))
		if err != nil {
			panic(err)
		}
	}
}


	// Open the zip archive for reading
	zipReader, err := zip.OpenReader(tempFile.Name())
	if err != nil {
		http.Error(w, "Error opening zip archive", http.StatusInternalServerError)
		return
	}
	defer zipReader.Close()

	// Iterate through the files in the archive
	for _, file := range zipReader.File {
		// Validate file name
		if filepath.Clean(file.Name) != "." {
			http.Error(w, "Invalid file name", http.StatusBadRequest)
			return
		}

		// Extract the file to a secure location
		extractedFilePath := filepath.Join("/secure/extraction/path", file.Name)
		err = os.MkdirAll(filepath.Dir(extractedFilePath), 0755)
		if err != nil {
			http.Error(w, "Error creating directory for extracted file", http.StatusInternalServerError)
			return
		}

		dstFile, err := os.OpenFile(extractedFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
		if err != nil {
			http.Error(w, "Error opening file for writing", http.StatusInternalServerError)
			return
		}

		fileInArchive, err := file.Open()
		if err != nil {
			http.Error(w, "Error opening file in archive", http.StatusInternalServerError)
			return
		}

		_, err = io.Copy(dstFile, fileInArchive)
		if err != nil {
			http.Error(w, "Error copying file to destination", http.StatusInternalServerError)
			return
		}

		dstFile.Close()
		fileInArchive.Close()
	}
}

}



