package sqli

import (
	"net/http"

	"github.com/gen2brain/go-unarr"
	"github.com/julienschmidt/httprouter"
)

type PathTraversal struct{}

func New() PathTraversal {
	return PathTraversal{}
}

func (PathTraversal) SetRouter(r *httprouter.Router) {
	r.GET("/path-traversal", pathTraversalHandler)
}

func pathTraversalHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	// Create a temporary file to hold the archive
	tempFile, err := os.CreateTemp("", "archive-*.zip")
	if err != nil {
		http.Error(w, "Error creating temporary file", http.StatusInternalServerError)
		return
	}
	defer tempFile.Close()
	defer os.Remove(tempFile.Name()) // clean up

	// Copy the request body to the temporary file
	_, err = io.Copy(tempFile, r.Body)
	if err != nil {
		http.Error(w, "Error copying request body to temporary file", http.StatusInternalServerError)
		return
	}

	// Seek back to the beginning of the file
	_, err = tempFile.Seek(0, 0)
	if err != nil {
		http.Error(w, "Error seeking to beginning of temporary file", http.StatusInternalServerError)
		return
	}

	// Open the zip archive for reading
	zipReader, err := zip.OpenReader(tempFile.Name())
	if err != nil {
		http.Error(w, "Error opening zip archive", http.StatusInternalServerError)
		return
	}
	defer zipReader.Close()

	// Iterate through the files in the archive
	for _, file := range zipReader.File {
		// Validate file name
		if filepath.Clean(file.Name) != "." {
			http.Error(w, "Invalid file name", http.StatusBadRequest)
			return
		}

		// Extract the file to a secure location
		extractedFilePath := filepath.Join("/secure/extraction/path", file.Name)
		err = os.MkdirAll(filepath.Dir(extractedFilePath), 0755)
		if err != nil {
			http.Error(w, "Error creating directory for extracted file", http.StatusInternalServerError)
			return
		}

		dstFile, err := os.OpenFile(extractedFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
		if err != nil {
			http.Error(w, "Error opening file for writing", http.StatusInternalServerError)
			return
		}

		fileInArchive, err := file.Open()
		if err != nil {
			http.Error(w, "Error opening file in archive", http.StatusInternalServerError)
			return
		}

		_, err = io.Copy(dstFile, fileInArchive)
		if err != nil {
			http.Error(w, "Error copying file to destination", http.StatusInternalServerError)
			return
		}

		dstFile.Close()
		fileInArchive.Close()
	}
}

}

