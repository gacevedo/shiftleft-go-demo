package sqli

import (
	"net/http"

	"github.com/gen2brain/go-unarr"
	"github.com/julienschmidt/httprouter"
)

type PathTraversal struct{}

func New() PathTraversal {
	return PathTraversal{}
}

func (PathTraversal) SetRouter(r *httprouter.Router) {
	r.GET("/path-traversal", pathTraversalHandler)
}

func pathTraversalHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	// Check if the request is over HTTPS
	if r.URL.Scheme != "https" {
		http.Error(w, "Invalid request scheme", http.StatusBadRequest)
		return
	}

	// Create a temporary directory to extract the files
	tempDir, err := ioutil.TempDir("", "unzip-")
	if err != nil {
		panic(err)
	}
	defer os.RemoveAll(tempDir) // clean up

	// Open the zip archive
	a, err := unarr.NewArchiveFromReader(r.Body)
	if err != nil {
		panic(err)
	}
	defer a.Close()

	// Extract each file from the archive
	for _, file := range a.Files() {
		// Validate the file path
		if filepath.HasPrefix(file.Name, "..") || filepath.IsAbs(file.Name) {
			panic("Invalid file path")
		}

		// Validate the file type
		mimeType, err := mimetype.DetectFile(file.Name)
		if err != nil || mimeType.Is("application/zip") {
			panic("Invalid file type")
		}

		// Extract the file
		_, err = file.Extract(filepath.Join(tempDir, file.Name))
		if err != nil {
			panic(err)
		}
	}
}


	// Open the zip archive for reading
	zipReader, err := zip.OpenReader(tempFile.Name())
	if err != nil {
		http.Error(w, "Error opening zip archive", http.StatusInternalServerError)
		return
	}
	defer zipReader.Close()

	// Iterate through the files in the archive
	for _, file := range zipReader.File {
		// Validate file name
		if filepath.Clean(file.Name) != "." {
			http.Error(w, "Invalid file name", http.StatusBadRequest)
			return
		}

		// Extract the file to a secure location
		extractedFilePath := filepath.Join("/secure/extraction/path", file.Name)
		err = os.MkdirAll(filepath.Dir(extractedFilePath), 0755)
		if err != nil {
			http.Error(w, "Error creating directory for extracted file", http.StatusInternalServerError)
			return
		}

		dstFile, err := os.OpenFile(extractedFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
		if err != nil {
			http.Error(w, "Error opening file for writing", http.StatusInternalServerError)
			return
		}

		fileInArchive, err := file.Open()
		if err != nil {
			http.Error(w, "Error opening file in archive", http.StatusInternalServerError)
			return
		}

		_, err = io.Copy(dstFile, fileInArchive)
		if err != nil {
			http.Error(w, "Error copying file to destination", http.StatusInternalServerError)
			return
		}

		dstFile.Close()
		fileInArchive.Close()
	}
}

}


